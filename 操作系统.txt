1. 面向对象的程序设计
  1.1 面向对象技术的基础概念
    该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度。
    所谓对象，是指现实世界中具有相同属性、服从相同规则的一
    系列事物（事物可以是一个物理体、一个概念或一个软件模块
    等）的抽象，而把其中的具体事物称为对象的实例。
    如：在操作系统中有进程对象、线程对象、储存器对象和文件
    对象等。
    - 对象：在面向对象技术中，是利用被封装的数据结构（变量）
    和一组对它进行操作的过程（方法），来表示某个对象的。对象
    中的变量（数据）也称为属性，它可以是单个标量或一张表。面
    向对象中的方法是用于执行某种功能的过程，它可以改变对象的
    状态，更新对象中的某些数值或作用于对象所要访问的外部资源。
    对象中的变量（数据）对外是隐蔽的，外界不能对它直接进行访
    问，必须通过该对象中的一组方法（操作函数）对它进行访问。
    同样，对象中的一组方法的实现细节也是隐蔽的，因此，对象中
    的变量可以得到很好的保护，而不会允许未经授权者使用和不正
    常的操作。
    - 对象类：在实践中，有许多对象可能表示的是同一类事物，每
    个对象具有具有自己的变量集合，而他们所具有的方法是相同的。
    如果为每一个相似的对象都定义一组变量和方法，显然是低效的，
    由此产生了“对象类”的概念，利用“对象类”来定义一组大体相似
    的对象。一个类同样定义了一组变量和针对该变量的一组方法，
    用他们来描述一组对象的共同属性和行为。类是对象上的抽象，
    对象是类的实例。对象类中所定义的变量在实例中均有具体的值。
    - 继承：在面向对象的技术中，可以根据已有类来定义一个新的
    类，新类被称为子类，原来的类被称为父类。继承是父类和子类
    之间共享变量和方法的机制，该机制规定，子类自动继承父类中
    定义的变量和方法，并允许子类再增加新的内容。一个父类可以
    定义多个子类，他们分别是父类的某种特例，父类描述了这些子
    类的公共变量和方法。类似地，这些子类又可以定义自己的子类，
    通过此途径可以生成一个继承的层次。另外，也允许一个子类有
    两个父类或多个父类，它可以从多个父类获得继承，此时称为“
    多重继承”。
Day2 进程管理
1. 进程控制块
  1.1 作用
    - 概念
      为了描述和控制进程的运行，系统为每个进程定义了一个数据
    结构——进程控制块PCB（Process Control Block），它是进程
    实体的一部分，是操作系统中最重要的记录型数据结构。
    - 作用
      PCB中记录了操作系统所需的、用于描述进程的当前情况以及控
    制进程运行的全部信息。进程控制块的作用是使一个在多道程序
    环境下不能独立运行的程序（含数据），称为一个能独立运行的
    基本单位，一个能与其它进程进行并发执行的进程。或者说。OS
    是根据PCB来对并发执行的进程进行控制和管理的。
    - 实例
      当系统创建一个新进程时，就为它建立了一个PCB；进程结束时
      又收回其PCB，进程于是也随之消亡了。PCB可以被操作系统的
      多个模块读或修改，如被调度程序、资源分配程序、中断处理
      程序以及监督和分析程序等修改。因为PCB经常被系统访问，尤
      其是被运行频率很高的进程及分派程序访问，故PCB应常驻内存。
      系统将所有的PCB组织成若干个链表（或队列）。存放在操作系
      统专门开辟的PCB区内。例如在Linux系统中用task_struct数
      据结构来描述每个进程的控制块，在Windows操作系统中则使用
      一个执行体进程模块（EPROCESS）来表示进程对象的基本属性。
  1.2 进程控制块中的信息
    1.2.1 进程标识符
      进程标识符用于唯一地标识一个进程。一个进程通常有两种标识
    符。
      - 内部标识符
    所有的操作系统中，都为每一个进程赋予了一个唯一的数字标识符，
    它通常是一个进程的符号。设置内部标识符只要是为方便系统使用。
      - 外部标识符
    由创建者提供，通常是由字母、数字组成，往往是由用户（进程）
    在访问该进程时使用。为了描述进程的家族关系，还应设置父进程
    及子进程标识。此外，还可以设置用户标识，指示拥有该进程的用
    户。
    1.2.2 处理机状态
      处理机状态信息主要是有处理机的各种寄存器中的内容组成的。
    处理机在运行时，许多信息都放在寄存器中。当处理机被中断时，
    所有这些信息都必须保存在PCB中，以便该进程重新执行时，能从
    断点继续执行。
      寄存器有：
    - 通用寄存器：有称为用户寄存器，用户程序可以访问，用于暂存
    信息。
    - 指令计数器：存放了要访问的下一条指令的地址。
    - 程序状态字PSW：包含状态信息，如条件码、执行方式、中断屏
    蔽标等。
    - 用户栈指针：指每个用户都有一个或若干个与之相连的系统栈，
    用于存放过程和系统调用参数及地址，栈指针指向该栈的栈顶。
    1.2.3 进程调度信息
      - 进程状态：指明进程的当前状态，作为进程调度和对换时的依
    据；
      - 进程优先级：用于描述进程使用处理机的优先级别的一个整数，
    优先级高的进程应优先获得处理机。
      - 进程调度所需的其它信息：它们与所采用的的进程调度算法有
    关，如进程已等待CPU的时间总和、进程已执行的时间总和等。
      - 事件：指进程有执行状态转变为阻塞状态所等待发生的事件，
    即阻塞原因。
    1.2.4 进程控制信息
      - 程序和数据的地址：指进程的程序和数据所在的内存或外存地址，
    以便再调度到该进程执行时，能从PCB中找到其程序和数据。
      - 进程同步通讯机制：指实现进程同步和进程通信时必须的机制，
    如消息队列、信号量等。
      - 资源清单：除CPU以外的、进程所需的全部资源及已经分配到该进
    程的资源的清单。
      - 连接指针：给出了本进程（PCB）所在队列中的下一个进程的PCB
    的首地址。
  1.3. 进程控制块的组织方式
    - 连接方式
      这是把具有同一状态的PCB，用其中的链接字链接成一个队列。这样，
    可以形成就绪队列、若干阻塞队列和空白队列等。对其中就绪队列按进
    程优先级的高低排列，把优先级高的进程的PCB排在队列前面。此外，
    也可根据阻塞原因的不同而把处于阻塞状态的进程的PCB排成等待I/O
    操作完成的队列和等待分配内存的队列。
    - 索引方式
      系统根据所有进程的状态建立几张索引表。如就绪索引表、阻塞索引
    表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。
2 进程控制
  - 概念：
    进程控制是进程管理中最基本的功能。它用于创建一个新进程，终止一
  个已完成的进程，或终止一个因出现某事件而使其无法运行下去的进程，
  还可以负责进程运行中的状态转换。如当一个正在执行的进程因等待某事
  件而暂时不能继续执行时，将其转换为阻塞状态，而当该进程所期待的事
  件出现时，又将该进程转换为就绪状态。进程控制一般是有OS的内核中的
  原语来实现的。
    - 原语：
      原语（Primitive）是由若干条指令组成的，用于完成一定功能的过
    程。与一般过程的区别在于——他们是“原子操作（Action Operation
    ）”。所谓原子操作，是指一个操作中的所有动作要么全做，要么全不做。
    原语的作用是为了实现进程的通信和控制，系统对进程的控制如不使用
    原语，就会造成状态的不确定性，从而达不到进程控制的目的。
  2.1 进程的创建
    2.1.1 进程图
      子进程可以继承父进程所拥有的资源，例如，继承父进程打开的文件，继
    承父进程所分配到的缓冲区等。当子进程被撤销时，应将其从父进程那里获
    得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的
    子进程。
    2.1.2 引起创建进程的事件
      在多道程序环境中，只有（作为）进程（时）才能在系统中运行。因此，
    为使程序能运行，就必须为它创建进程。导致一个进程去创建另一个进程的
    典型事件，可以有一下四类：
    - 用户登录：在分时系统中，用户在终端键入登录命令后，如果是合法用户，
    系统将为该终端建立一个进程，把它插入就绪队列中。
    - 作业调度：在批处理系统中，当作业调度程序按一定的算法调度到某作业
    时，便将该作业装入内存，为它分配必要的资源，并立即为它创建进程，再
    插入就绪队列中。
    - 提供服务：当运行中的用户程序提出某种请求后，系统将专门创建一个进
    程来提供用户所需的服务，例如，用户程序要求进行文件打印，操作系统将
    为它创建一个打印进程。
    - 应用请求：上述三种情况，都是由系统内核为它创建一个新进程。而第四
    类事件则是基于应用程序的需求，由它自己创建一个新进程，以便使新进程
    以并发运行方式完成特定任务。
    2.1.3 进程的创建
    - 申请空白PCB：为新进程申请获得唯一的数字表标识符，并从PCB集合中索
    取一个空白PCB。
    - 为新进程分配资源：为新进程的程序和数据以及用户栈分配必要的内存空
    间。
    - 初始化进程控制块：PCB初始化包括——初始化标识信息、初始化处理机状
    态信息、初始化处理机控制信息。
    - 将新进程插入就绪队列，如果进程就绪队列能够接纳新进程，便将新进程
    插入就绪队列。
  2.2 进程的终止
    2.2.1 引起进程终止的事件
      - 正常结束
        在任何计算机系统中，都应有一个用于表示进程已经运行完成的指示。
      - 异常结束
        在进程运行期间，由于出现某种错误和故障而迫使进程终止。
        如：越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、
      算数运算错、I/O故障等。
      - 外界干预
        进程应外界的请求而终止运行，而不是进程运行中出现了异常事件。
        - 操作员或操作系统干预：由于某种原因，如发生了死锁，由操作员或
        操作系统终止该进程。
        - 父进程请求：父进程拥有终止自己子孙进程的权力。
        - 父进程终止：当父进程终止时，OS将他所有的子孙进程终止。
    2.2.2 进程的终止过程
      如果系统中发生了上述终止进程的某事件，OS便调用终止原语，按下述过
      程去终止制定的进程。
      - 根据被终止进程的标识符，从PCB集合中检索出该进程的PCB，从中读出
      改进程的状态。
      - 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标
      志为真，用于指示该进程被终止后重新进行调度。
      - 若该进程还有子孙进程，还应终止其所有子孙进程，已防他们成为不可
      控的进程。
      - 将被终止进程所拥有的全部资源，或者归还给父进程，或者归还给系统。
      - 将被终止进程（PCB）从所在队列（或链表）中移出，等待其它程序来
      收集信息。
  2.3 进程的阻塞与唤醒
    2.3.1. 引起进程阻塞和唤醒的事件
      - 请求系统服务
        当正在执行的进程请求操作系统提供服务时，由于某种原因，操作系统
      并不能立即满足该进程的要求时，改进程只能转变为阻塞状态来等待。  
      - 启动某种操作
        当进程启动某种操作后，如果该进程必须在改操作完成之后才能继续执
      行，则必须先使该进程阻塞，等待该操作完成。
      - 新数据尚未到达
        对于相互合作的进程，如果其中一个进程需要先获得另一（合作）进程
      提供的数据后才能进行处理，则只要其所所需的数据尚未达到，该进程只
      有（等待）阻塞。
      - 无新工作可做
        系统往往设置一些具有某特定功能的系统进程，每当这种进程完成任务
      后，便把自己阻塞起来以等待新任务的到来。
    2.3.2 进程阻塞过程
      正在执行的进程，当发现上述事件时，由于无法继续执行，于是便通过调
    用阻塞原语block把自己阻塞。所以，阻塞是进程自身的一种主动行为。进
    入block过程后，此时还处于执行状态，所以应先立即停止执行，把进程控
    制块中的现行状态由“执行”改为“阻塞”，并将PCB插入阻塞队列。最后，转
    调度程序进行重新调度，将处理机分配给另一就绪程序进行切换，亦即，保
    留被阻塞进程的处理机状态（在PCB中），再按新建进程的PCB中的处理机状
    态设置CPU的环境。
    2.3.3 进程唤醒过程
      当被阻塞进程所期待的事件出现时，则由有关进程调用唤醒原语wakeup（），
    等待该事件的进程唤醒。
      唤醒原语执行过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，
    将其PCB中的现行状态由阻塞改为就绪，然后将PCB插入到就绪队列中。
      应当指出，block原语和wakeup原语是一对作用刚好相反的原语。因此，如
    果在某进程中调用了阻塞原语，则必须在与之相合作的另一进程中或其他相关
    的进程中安排唤醒原语，以能唤醒阻塞进程。否则，被阻塞进程会因不能被唤
    醒而长久地处于阻塞状态，从而再无机会继续执行。
    2.3.4 进程的激活与挂起
      - 进程的挂起：当发生引起进程挂起的事件时。
      - 进程的激活：当发生激活进程的事件时。
  2.4 进程同步
    进程同步的主要任务是多个相关进程在执行次序上进行协调，以使并发执行的
  诸程序之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。
    2.4.1 进程同步的制约关系
      - 两种形式的制约关系
        在多道程序环境下，当程序并发执行时，由于资源共享和进程合作，使同
      处一个系统中的诸进程之间可能存在以下两种形式的制约关系。
        - 间接制约关系：同处一个系统中的进程，通常都共享着某种系统资源，
      如共享CPU、共享I/O设备等。所谓间接相互制约即源于这种资源共享。如存
      在两个进程A和B，当A进程提出打印请求时，系统已将唯一的打印机分配给了
      进程B，那么A只能阻塞；只有等到B将打印机释放，A进程才能由阻塞改为就
      绪状态。
        - 直接制约关系：这种制约主要源于进程间的合作。例如，有一输入进程
      A通过单缓冲向进程B提供数据。当该缓冲空时，计算进程因不能获得所需数
      据而阻塞，而当进程A把数据输入缓冲区后，便将进程B唤醒；反之，当缓冲
      区已满时，进程A因不能再向缓冲区投放数据而阻塞，当进程B将缓冲区数据
      取走后便可唤醒A。
    2.4.2 临街资源
      许多硬件资源如打印机、磁带机等，都属于临街资源（Critical Resouce），
    诸进程间应采用互斥方式，实现对这种资源的共享。
    2.4.3 临界区
      无论硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问。
    人们把在每个进程中访问临界资源的那段代码称为临界区（critical section
    ）。显然，若能保证诸进程互斥地进入自己的临界区，便可实现诸进程对临界资
    源的访问。所以，每个进程在进入临界区之前，应先对欲访问的临界资源进行访
    问，并设置它正被访问的标志；如果该临界资源正被某进程访问，则本进程不能
    进入临界区。因此，必须在临界区前面增加一段用于进行上述检查的代码，把这
    段代码称为进入区（entry section）。相应地，在临界区后面也要加上一段称
    为退出区（exit section）的代码，用于将临界区正被访问的标志恢复为未被
    访问的标志。进程中除进入区、临界区和退出区之外的其余部分的代码称为剩余
    区。
    2.4.4 同步机制应遵循的规则
      为实现进程互斥地进入自己的临界区，更多的是在系统中设置专门的同步机构
    来协调各进程间的运行。所有同步机制都应遵循下述四条准则：
      - 空闲让进：当进程处于临界区时，表明临界资源处于空闲状态，应应允一个
    请求进入临界区的进程立即进入自己的临界区，以有效的利用临界资源。
      - 忙则等待：当已有进程进入临界区时，表明资源正在被访问，因而其它试图
    进入临界区的进程必须等待，以保证对临界资源的互斥访问。
      - 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入到自己
    的临界区，以避免陷入“死等”状态。
      - 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以避免进
    程陷入“忙等”状态。
  2.5 进程通信
    进程通信，是指进程之间的信息交换，其所交换的信息量少者是一个状态或数值，
  多者则是成千上万个字节。进程之间的互斥和同步，由于其所交换的信息量少而被
  归结为低级通信。
    2.5.1 进程通信的类型
      - 低级通信
      - 高级通信：共享存储器系统、消息传递系统及管道通信系统
        - 共享存储器系统：相互通信的进程共享某些数据结构或共享存储区，进程
      之间能够通过这些空间进行通信。
          - 共享数据结构的通信方式：低效的，只适于传递相对少量的数据。
          - 共享存储区的通信方式：适合传输大量数据的高级通信。
        - 消息传递系统
          进程间的数据是以格式化的消息为单位的，在计算机网络中，message
        又被称为报文。
        - 管道通信
          所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通
        信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送
        进程（即写进程），以字符流形式将大量的数据送入管道；而接受管道输
        出的接受进程（即读进程），则从管道中接受（读）数据。由于发送进程
        和接受进程是利用管道进行通信的，故又称为管道通信。
          为了协调双方的通信，管道机制必须提供一下三方面的协调能力：
          - 互斥：当一个进程正在对pipe执行读/写操作时，其它（另一）进程
          必须等待。
          - 同步：当写（输入）进程把一定数量的数据写入pipe，便去睡眠等待，
          知道读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，
          也应睡眠等待，直到写进程数据写入管道后，才将之唤醒。
          - 确定对方是否存在，只有确定对方已存在时，才能进行通信。
    2.5.2 消息传递通信的实现方法
      进程间通信时，源进程可以直接或间接地将消息传送给目标进程，由此可将
    进程通信分为直接通信和间接通信。
      - 直接通信方式：指放松进程利用OS所提供的的命令，直接把消息发送给目
      标进程。此时，要求发送进程和接受进程都以显式方式提供对方的标识符。
      - 间接通信方式：指进程之间通信需要通过作为数据结构的实体。该实体用
      来暂存发送进程给目标进程的消息；接受进程则从该实体中取出对方发送给
      自己的消息。通常把这种中间实体称为信箱。消息在信箱中可以安全地保存，
      只允许核准的目标用户随时读取。
    2.5.3 进程同步方式
      进程间进行通信时，同样需要有进程同步机制，使各进程间能协调通信。不
    论是发送进程，还是接受进程，在完成消息的发送或接受后，都存在两种可能
    性，即进程或继续发送（接受），或阻塞。所以，有以下三种情况发生：
      - 发送进程阻塞，接受进程阻塞：这种情况主要是用于进程之间紧密同步，
      发送进程和接收进程之间无缓冲。这两个进程平时都处于阻塞状态，知道有
      消息传递时。这种同步方式称为汇合。
      - 发送进程不阻塞，接受进程阻塞：这是一种应用最广的进程同步方式。平
      时发送进程不阻塞，因而它可以尽快地把一个或多个消息发送多个目标；而
      接收进程平时则处于阻塞状态，直到发送进程发来消息时才被唤醒。
      - 发送进程和接受进程均不阻塞：这也是一种较为常见的进程同步形式。平
      时，发送进程和接收进程都在忙于自己的事情，仅当发生某事件使它无法继
      续运行时，才把自己阻塞起来等待。例如，在发送进程和接收进程之间联系
      着一个消息队列时，该消息队列最多能接纳n个消息，这样，发送进程便可以
      连续地向消息队列发送消息而不必等待；接收进程也可以连续地从消息队列
      取得信息，也不必等待。只有当消息队列中的消息数已达到n个时，即消息队
      列已满，发送进程无法向消息队列中发送消息时才会阻塞；类似地，只有当
      消息队列中的消息数为0，接收程序已无法从消息队列中取得消息时才会阻塞。
    2.5.4 消息缓冲队列通信机制
      在这种通信机制中，发送进程利用Send原语将消息直接发送给接收进程；接收
    进程则利用Receive原语接收消息。
    - 消息缓冲队列通信机制中的数据结构
      - 消息缓冲区：在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲
      区。  
      - PCB中有关通信的数据项：在此通信机制时，还应在进程的PCB中增加消息队
      列首指针，用于对消息队列进行操作。
    - 发送原语
    - 接受原语
  2.6 线程
    在操作系统中，线程是能够独立运行的基本单位。
    2.6.1 线程的基本概念
      - 线程的引入
        在操作系统中引入进程的目的，是为了使多个程序能并发执行，以提高资源
      利用率和系统吞吐量，那么，操作系统再引入线程，则是为了减少程序在并发
      执行时所付出的时空开销，使OS具有更好的并发性。
        - 进程的基本属性：1，进程是一个可以拥有资源的独立单位；2，进程同时
        又是一个可独立调度和分派的基本单位。
        正是由于进程有这两个基本属性，才使之成为一个能独立运行的基本单位，
      从而也就构成了进程并发执行的基础。然而，为使程序能并发执行，系统还必
      须进行一下的一系列操作：
        - 创建进程：系统创建进程时，必须为它分配其所需的、除处理机以外的所
      有资源，如内存空间、I/O设备，以及建立相应的PCB。
        - 撤销进程：系统撤销进程时，又必须对其所占有的资源执行回收操作，然
      后再撤销PCB。
        - 进程切换：进程进行切换时，由于要保留当前进程的CPU环境和设置新选中
        进程的CPU环境，因此需花费不少的处理机时间。
          换言之，由于进程是一个资源的拥有者，因此在创建、撤销和切换中，系
        统必须为之付出较大的时空开销。正因如此，在系统中所设置的进程数目不
        宜过多，进程切换的频率也不宜过高，这也就限制了并发程度的进一步提高。
        所以希望将进程的两个属性分开，由操作系统分开处理，即作为调度和分派
        的基本单位，不能同时作为拥有资源的单位；而对于拥有资源的基本单位，
        又不对之进行频繁的切换。正是这种思想的指导下，形成了线程的概念。
      - 线程与进程的比较
        线程具有许多传统进程所具有的特征，传统进程相当于只有一个线程的任
      务。在引入线程的操作系统中，通常一个进程都拥有若干个线程，至少也有
      一个线程。
        从以下四个方面对比线程和进程的异同：
        - 调度：在引入线程的操作系统中，把线程作为调度和分派的基本单位，
        而进程作为资源拥有的基本单位，把传统进程的两个属性分开，使线程基
        本上不拥有资源，这样线程便能轻装前进，从而显著地提供系统的并发程
        度。在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的
        线程切换到另一个进程中的线程时，将会引起进程的切换。
        - 并发性：在引入线程的操作系统中，不进进程之间可以并发执行，而且
        在一个进程中的多个线程之间亦可并发执行，使操作系统具有更好的并发
        性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。
        - 拥有资源：不论是传统的操作系统，还是引入了线程的操作系统，进程
        都可以拥有资源，是系统中拥有资源的一个基本单位。一般而言，线程自
        己不拥有系统资源（也有一点必不可少的资源），但它可以访问其隶属进
        程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开
        的文件I/O设备等，可以供该进程中的所有线程所共享。
        - 系统开销：创建或撤销进程时，系统都要为之创建和回收进程控制块，
        分配或回收资源，如内存空间和I/O设备等，操作系统所付出的开销明显
        大于线程创建或撤销时的开销。
      - 线程的属性
        在多线程操作系统中，通常实在一个进程中包含多个进程，每个线程都是
        作为利用CPU的基本单位，它是花费最小开销的实体。线程具有下述属性。
        - 轻实体型：线程中的实体基本上不拥有系统资源，只是有一点必不可少
        的、能保证其独立运行的资源，如用于控制线程运行的线程控制块TCB，
        用于指示被执行指令序列的程序计数器，保留局部变量、少数状态参数和
        返回地址等的一组寄存器和堆栈。
        - 独立调度和分派的基本单位：在多线程操作系统中，线程是能独立运行
        的基本单位，也是独立调度和分派的基本单位。
        - 可并发性：在一个进程中的多个线程之间可以并发执行，甚至允许在一
        个进程中的所有线程都能并发执行；同样，不同进程中的线程也能并发执
        行。
        - 共享进程资源：在同一进程中的各个线程都可以共享该进程所拥有的的
        资源，这首先表现在所有进程都具有相同的地址空间（进程的地址空间）。
        这意味着线程可以访问该地址空间中的每一个虚地址；此外，还可以访问
        进程所拥有的已打开文件、定时器、信号量机构等。
      - 线程的状态
        - 状态参数：在操作系统中的每一个线程都可以利用进程标识符和一组状
        态参数进行描述。状态参数包含这样几项——1、寄存器状态，它包括程序
        计数器PC和堆栈指针中的内容；2、堆栈，在堆栈中通常保存有局部变量
        和返回地址；3、线程运行状态，用于描述苏线程正处于何种运行状态；
        4、优先级，描述线程执行的有限程度；5、线程专有存储器，用于保存
        线程自己的局部变量拷贝；6、信号屏蔽，即对某些信号加以屏蔽。
        - 线程运行状态：各线程之间也存在着共享资源和相互合作的制约关系，
        致使线程在运行时也具有间断性。线程在运行时具有下述三种基本状态——
        1、执行状态，表示线程正获得处理机而运行；2、就绪状态，指线程已具
        备各种执行条件，一旦获得CPU便可执行的状态；3、阻塞状态，指线程
        在执行中因某事件而受阻，处于执行时的状态。
      - 线程的创建和终止
        在多线程操作系统环境下，应用程序在启动时，通常仅有一个线程在执行，
        该线程被称为“初始化线程”。
      - 多线程操作系统中的进程
        在多线程操作系统中，进程时作为拥有系统资源的基本单位，通常包含多个
        线程并为他们提供资源，但此时的进程就不再作为一个执行的实体。多线程
        操作系统中的进程有以下属性：
          - 作为系统资源分配的单位：在多线程OS中，仍是将进程作为系统资源分
          配的基本单位，在任一进程中所拥有的资源包括收到分别保护的用户地址
          空间、用于实现进程间和线程间同步通信的机制、已打开的文件和已申请
          到的I/O设备，以及一张由核心进程维护的地址映射表，该表用于实现用
          户程序的逻辑地址以及到其内存物理地址的映射。
          - 可包含多个线程：一个进程可以有多个相对独立的线程，数目可多可
          少，但至少要有一个线程，由进程为这些（个）线程提供资源运行环境，
          使这些进程可并发执行。
          - 进程不是一个可执行的实体。在多线程OS中，是把线程作为独立运行的
          基本单位，所以此时的进程已不再是一个可执行的实体。但进程仍具有与
          执行相关的状态。所谓进程处于执行状态，实际上是指进程中的某线程正
          在执行。
      2.6.2 线程间的同步和通信
        为使系统中的多线程能有条不紊的运行，在系统中必须提供用于实现线程间
        同步和通信的机制。多线程中的同步机制有：
        - 互斥锁（mutex）：互斥锁是一种比较简单的、用于实现线程间对资源互
        斥访问的机制。由于操作互斥锁的事件和空间开销都比较低，因而较适合高
        频率度使用的关键共享数据和程序段。
        - 条件变量：在许多情况下，只利用互斥锁来实现访问可能会引起死锁。解
        决方法是，通过引入条件变量。每一条条件变量通常都与一个互斥锁一起使
        用，亦即，在创建一个互斥锁时便联系着一个条件变量。单纯的互斥锁用于
        短期锁定，主要是用来保证对临界区的互斥进入。而条件变量则用于线程的
        长期等待，直至所等待的资源成为可用的资源。
        - 信号量机制：用于实现进程同步的最常用工具，也可用于多线程OS中，实
        现诸线程或进程之间的同步。为了提供效率，可为线程和进程分别设置相应
        的信号量。
          - 私用信号量：当线程需利用信号量来实现同一进程中各线程的同步时，
          可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程
          序的地址空间中。私用信号量属于特定的进程所有，OS并不知道私用信号
          量的存在，因此，一旦发生私用信号量的占有者异常结束，但并未释放信
          号量所占有空间的情况时，系统无法使它恢复为0（空），也不能将它传
          送给下一个请求它的线程。
          - 共用信号量：共用信号量是为实现不同进程间或不同线程间的同步而设
          置的。因为它有一个公开的名字供所有的进程使用，所以把它称为公用信
          号量。其数据结构是存放在受保护的系统存储区中，由OS为它分配空间进
          行管理，故也称为系统信号量。
3. 处理机调度与死锁
  - 处理机：处理机包括中央处理器、主存储器、输入-输出接口；处理机是处理计算
  机系统中存储程序和数据，并按照程序规定的步骤执行指令的部件。程序是描述处理
  机完成某项任务的指令序列。指令则是处理机能直接解释、执行的信息单位。
  - 在多道程序环境下，主存中有着多个进程，其数目往往多于处理机数目。这就要求
  系统能按某种算法，动态地把处理机分配给就绪队列中的一个进程，使之执行，分配
  处理机的任务是由处理机调度程序完成的。由于处理机是最重要的计算机资源，提高
  处理机的利用率及改善系统性能（吞吐量、响应时间），在很大程度上取决于处理机
  调度性能的好坏，因而，处理机调度便成为操作系统设计的中心问题之一。
  3.1 处理机调度的层次
    在多道程序系统中，一个作业被提交后必须经过处理机调度后，方能获得处理机执
  行。对于批量型作业而言，通常需要经历作业调度（又称高级调度或长程调度）和进
  程调度（又称低级调度或短程调度）两个过程后方能获得处理机；对于终端型作业，
  则通常只需经过进程调度就可获得处理机。在较完善的操作系统中，为提高内存的利
  用率，往往还设置了中级调度（又称中程调度）。
    3.1.1 高级调度
    高级调度的主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内
    存，也就是说，它的调度对象是作业。
    - 作业和作业步
      - 作业：作业是一个比程序更为广泛的概念，它不仅包含了通常的程序和数据，
      还应配有一份作业说明书，系统根据该说明书来对程序的运行进行控制。在批量
      处理系统中，是以作业为基本单位从外存调入内存的。
      - 作业步：通常，在作业运行期间，每个作业都必须经过若干个相对独立，又相
      互关联的顺序加工步骤才能得到结果，我们把其中的每一个加工步骤称为一个作
      业步，各作业步之间存在着相互联系，往往是把上一个作业步的输出作为下一个
      作业步的输入。例如，一个典型的作业可分成三个作业步：
        - “编译”作业步，通过执行编译程序对源程序进行编译，产生若干个目标程序
        段；
        - “连结装配”作业步，将“编译”作业步所产生的若干目标程序段装配成可执行
        的目标程序；
        - “运行”作业步，将可执行的目标程序读入北村并控制其运行。
      - 作业流：若干作业进入系统后，被一次存放在外存上，这便形成了输入的作业
      流；在操作系统的控制下，逐个作业进行处理，于是便形成了处理作业流。
    - 作业控制块 JCB（Job Control Block）
      为了管理和调度作业，在多道批批处理系统中为每个作业设置了一个作业控制块，
      如同进程控制块是进程在系统中存在的标志一样，它是作业存在系统中存在的标
      志，其保存了系统对作业进行管理和调度所需的全部信息。通常应包含的有：作
      业标识、用户名称、用户账户、作业类型（CPU繁忙型、I/O繁忙型、批量型、终
      端型）、作业状态、调度信息、资源需求、进入系统时间、开始处理时间、作业
      完成时间、作业退出时间、资源使用情况等。
      每当作业进入系统时，系统便为每个作业建立一个JCB，根据作业类型将它插入相
      应的后备队列中。作业调度程序依据一定的调度算法来调度它们，被调度到的作业
      将会装入到内存。在作业运行期间，系统就按照JCB中的信息对作业进行控制。当
      一个作业执行结束进入完成状态时，系统负责回收分配给它的资源，撤销它的作业
      控制块。
    - 作业调度
      作业调度的主要功能是根据作业控制块中的信息，审查系统能否满足用户作业的资
      源需求，以及按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为
      他们创建进程、分配必要的资源。然后再将新创建的进程插入就绪队列，准备执行。
      因此，有时也把作业调度称为接纳调度。每次执行作业调度时，都必须做出以下两
      个决定：
        - 决定接纳多少个作业
          作业调度每次要接纳多少个作业进入内存，取决于多道程序度，即允许多少个
          作业同时在内存中运行。因此，多道程序度的确定应根据系统的规模和运行速
          度等情况做适当的折衷。
        - 决定接纳哪些作业
          应将哪些作业从外存调入内存，这将取决于所采用的的调度算法。最简单的是
          先来先服务调度算法，这是指将最早进入外存的作业最先调入内存；较常用的
          一种算法是短作业优先调度算法，这将外存上最短的作业最先调入内存；另一
          种较常用的基于作业优先级的调度算法，该算法是将外存上优先级最高的作业
          优先调入内存；比较好的一种算法是“响应比高者优先”的调度算法。
    3.1.2 低级调度
      低级调度也称为进程调度和短程调度，它所调度的对象是进程（或内核级线程）。
      进程调度是最基本的一种调度，在多道批处理、分时和实时三种类型的OS中，都必
      须配置这级调度。
      - 低级调度的功能
        - 保存处理机的现场信息。在进程调度进行调度时，首先将需要保存当前进程的
        处理机的现场信息，如程序计数器、多个通用寄存器的内容等，将它们送入该进
        程的进程控制块（PCB）中的相应单元。
        - 按某种算法选取进程。低级调度程序按照某种算法如优先数算法、轮转法等，
        从就绪队列中选取一个进程，把它的状态改为运行状态，并准备把处理机分配
        给它。
        - 把处理机分配给进程。有分派程序把处理器分配给进程。
      - 进程调度中的三个基本机制
        - 排队器。为了提高进程调度的效率，应事先将系统中所有的就绪进程按照一定
        的方法排成一个或多个队列，以便调度程序能最快地找到它。
        - 分派器（分派程序）。分派器把由进程调度程序所选定的进程，从就绪队列中
        取出该进程，然后进行上下文切换，将处理机分配给它。
        - 上下文切换机制。当对处理机进行切换时，会发生对上下文切换操作。现在已
        有通过硬件（采用两组或多组寄存器）的方法来减少上下文切换的事件。一组寄
        存器供处理机在系统状态时使用，另一组寄存器供应用程序使用。在这种条件下
        的上下文切换只需改变指针，使其指向当前寄存器即可。
      - 进程调度方式
        - 非抢占方式
          在采用这种调度方式时，一旦把处理机分配给某进程后，不管它要运行多长时
          间，都一直让它运行下去，绝不会因为时钟中断等原因而抢占正在运行进程的
          处理机，也不允许其他进程抢占已经分配给它的处理机。直至该进程完成，自
          愿释放处理机，或发生某事件阻塞时，才再把处理机分配给其他进程。在采用
          非抢占调度方式时，可能引起进程调度的因素有：
            - 正在执行的进程执行完毕，因发生某事件而不能继续执行；
            - 执行中的进程因提出I/O请求而暂停执行；
            - 在进程通信或同步过程中执行了某种操作原语，如P操作（wait操作）、
            Block原语、Wakeup原语等。
          这种调度方式的优点是实现简单，系统开销小，适用于大多数的批处理系统环
          境。但难以满足紧急任务的要求——立即执行，所以可能造成难以预料的后果。
          显然，在要求严格的实时系统中，不宜采用这种调度方式。
        - 抢占方式
          这种调度方式允许调度程序根据某种原则去暂停某个正在执行的进程，将已分
          配给该进程的处理机重新分配给另一进程。抢占方式的优点是，可以防止一个
          长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是满足对
          响应时间有着比较严格要求的任务的需求时。但抢占方式比非抢占方式调度所
          需付出的开销较大。抢占调度方式基于的原则有：
            - 优先权原则。重要和紧急的作业赋予较高的优先权，比正在执行进程的优
            先权高，便停止当前运行的进程，将处理机分配给优先权高的新到的进程。
            - 短作业优先原则。短进程到达时，会暂停长作业的进程，抢占当前较长作
            业的处理机。
            - 时间片原则。各进程之间按时间片轮流运行，当一个时间片用完后，便停
            止该进程的执行而重新进行调度。这种原则适用于分时系统、大多数的实时
            系统，以及要求较高的批处理系统。
    3.1.3 中级调度
      引入中级调度器的主要目的是为了提高内存利用率和系统吞吐量。为此，那些暂时
      不能运行的进程不再占用宝贵的内存资源，而将它们调到外存上等待，把此时的进
      程状态称为就绪驻外存状态或挂起状态。当这些进程又具备运行条件且内存又有空
      闲时，有中级调度器来决定把外存上的那些又具备运行条件的就绪进程重新调入内
      存，并修改其状态，挂在就绪队列上等待进程调度。中级调度实际上就是存储器管
      理中的对换功能。
  3.2 调度队列模型和调度准则
    3.2.1 调度队列模型
      - 仅有进程调度的调度队列模型
        在分时系统中，通常仅设置进程调度，用户键入的命令和数据都直接送入内存。
        对于命令，是由OS为之建立一个进程。系统可以把处于就绪状态的进程组织成
        栈、树或一个无序链表，最终所采用形式则与OS类型和所采用的调度算法有关。
        例如，在分时系统中，常把就绪进程组织成FIFO队列形式。每当OS创建一个新
        进程，便将它挂在就绪队列的末尾，然后按时间片轮转方式运行。每个进程执
        行时都可能出现以下三个情况：
        - 任务在给定时间片内已经完成，改进程便在释放处理机后进入完成状态；
        - 任务在本次分得的时间片内尚未完成，OS便将该任务放入就绪队列的末尾；
        - 在执行期间，进程因为某事件而被阻塞后，被OS放入阻塞队列。
      - 具有高级和低级调度的调度队列模型
        在批处理系统中，不进需要进程调度，而且还要有作业调度，由后者按一定的
        作业调度算法，从外存的后备队列中选择一批作业调入内存，并为它们建立进程，
        送入就绪队列，然后才由进程调度按照一定的进程调度算法选择一个进程，把处
        理机分配给进程。
      - 同时具有三级调度的调度队列模型
    3.2.2 选择调度方式和调度算法的若干准则
      - 面向用户的准则
        - 周转时间短
        - 响应时间快
        - 截止时间的保证
        - 优先权准则
      - 面向系统的准则
        - 系统吞吐量高
        - 处理机利用率好
        - 各类资源平衡利用
  3.3 调度算法
    - 概念：根据系统资源的分配策略所规定的资源分配算法。
    3.3.1 先来先服务和短作业（进程）优先调度算法
      - 先来先服务调度算法（FCFS）
      - 短作业（进程）优先调度算法
    3.3.2 高优先权优先调度算法
      - 优先权调度算法的类型
        - 非抢占式优先权调度算法
        - 抢占式优先权调度算法
      - 优先权的类型
        - 静态优先权
        - 动态优先权
      - 高响应比优先调度算法
    3.3.3 基于时间片的轮转调度算法
      - 时间片轮转法
        - 基本原理
          在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个
          队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大
          小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，
          调度程序便根据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，
          再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就
          可以保证就绪队列中所有的进程在一给定的时间内均获得一时间片的处理机执行时
          间。换言之，系统能在给定的时间内响应所有用户的请求。
          - 时间片大小的确定
            在时间片轮转算法中，时间片的大小对系统性能有很大的影响，如选择很小的时
            间片将有利于短作业，因为它能较快地完成，但会频繁地发生中断、进程上下文
            的切换，从而增加系统的开销；反之，如果选择太长的时间片，使得每个进程都
            能在一个时间片内完成，时间片轮转算法便退化为FCFS算法，无法满足交互用户
            的需求。一个较为可取的大小是，时间片略大于一次典型的交互所需要的时间。
            这样大多数进程在一个时间片内完成。
          - 多级反馈队列调度算法
            在采用多级反馈调度算法的系统中，调度算法的实施过程如下所述：
            - 应设置对个就绪队列，并为各个队列赋予不同的优先级。在第一个队列的优先
            级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列
            中进程执行时间片的大小也各不相同，在优先权越高的队列中，为每个进程所规
            定的执行时间片就越小。
          - 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待
          调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果
          它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列末尾，再同样
          地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再
          依次将它放到第三队列，...，如此下去，当一个长作业（进程）从第一队列依次
          降到第n队列后，在第n队列中便采取时间片轮转的方式运行。
          - 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1~（i-1）
          队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中位某些进
          程服务时，又有新进程进入优先权较高的队列（第1~（i-1）中的任何一个队列），
          则此时新进程将占据正在运行进程的处理机，即由调度程序把正在运行的进程放回到
          第i队列的末尾，把处理机分配给新到的高优先权进程。
        - 多级反馈队列调度算法的性能
          多级反馈队列调度算法具有较好的性能，能很好地满足各种类型用户的需要。
          - 终端型作业用户
          - 短批处理作业用户
          - 长批处理作业用户
  3.4 实时调度
    实时调度——为了满足实时系统对调度的要求。
    3.4.1 实现实时调度的基本条件
      - 提供必要的信息
        - 就绪时间
        - 开始截至时间和完成截至时间
        - 处理时间
        - 资源要求
        - 优先级
      - 系统处理能力强
      - 采用抢占式调度机制
      - 具有快速切换机制
        - 对外部中断的快速响应能力
        - 快速的任务分派能力
  3.5 产生死锁的原因和必要条件
    在多道程序系统中，虽可借助多个进程的并发执行来改善系统的资源利用率，提高系统的吞
    吐量，但可能发生一种危险——死锁。所谓死锁（Deadlock），是指多个进程在运行过程中因
    争夺资源而造成的一种僵局（DeadlyEmbrace），当进程处于这种僵持状态时，若无外力作
    用，他们讲无法向前推进。例如，把信号量作为同步工具时已提及到，若多个wait和signal
    操作顺序不当，会产生进程死锁。
    3.5.1 产生死锁的原因
      - 竞争资源：
      - 进程间推进顺序非法：